use esp_idf_sys as _; // If using the `binstart` feature of `esp-idf-sys`, always keep this module imported
use esp_idf_hal::{delay::FreeRtos, gpio::PinDriver, peripherals::Peripherals};
use log::*;
use esp_idf_svc::{
    eventloop::EspSystemEventLoop,
};
use anyhow::{bail, Result, Error};
use std::{net::{UdpSocket, SocketAddr}, time::{SystemTime, UNIX_EPOCH, Duration, Instant}, thread};
use std::net::{TcpListener, TcpStream};
use smol;
use toml_cfg::toml_config;
use futures;

pub mod wifi;

use crate::wifi::wifi;

#[toml_cfg::toml_config]
pub struct Config {
    #[default("")]
    wifi_ssid: &'static str,
    #[default("")]
    wifi_psk: &'static str,
    #[default("192.168.0.104")]
    target_ip: &'static str,
    #[default(29000)]
    target_port: u16,
    #[default(29001)]
    outbound_port: u16,
}

fn main() -> Result<()> {
    // It is necessary to call this function once. Otherwise some patches to the runtime
    // implemented by esp-idf-sys might not link properly. See https://github.com/esp-rs/esp-idf-template/issues/71
    esp_idf_sys::link_patches();
    // Bind the log crate to the ESP Logging facilities
    esp_idf_svc::log::EspLogger::initialize_default();
    // info!("Hello, world!");

    // // Get all the peripherals
    // let peripherals = Peripherals::take().unwrap();
    // // Initialize Pin 8 as an output to drive the LED
    // let mut led = peripherals.pins.gpio4.into_output().unwrap();

    // !!! pins that should not be used on ESP32: 6-11, 16-17
    // those are reserved for SPI and trying to use them will result in a watchdog timer reset
    let peripherals = Peripherals::take().unwrap();

    let sysloop = EspSystemEventLoop::take()?;

    let input_pin = PinDriver::input(peripherals.pins.gpio13).unwrap();
    let mut led_pin = PinDriver::output(peripherals.pins.gpio12).unwrap();

    // The constant `CONFIG` is auto-generated by `toml_config`.
    let app_config = CONFIG;

    info!("SSID: {}", app_config.wifi_ssid);
    info!("PSK: {}", app_config.wifi_psk);
    
    // Connect to the Wi-Fi network
    let wifi_interface = wifi(
        app_config.wifi_ssid,
        app_config.wifi_psk,
        peripherals.modem,
        sysloop,
    ).expect("Couldn't connect to WiFi!");

    info!("IP (sta): {}", wifi_interface.sta_netif().get_ip_info()?.ip);
    info!("IP (ap): {}", wifi_interface.ap_netif().get_ip_info()?.ip);

    let socket_inbound_address = SocketAddr::from(([0, 0, 0, 0], 29001));
    let socket_outbound_address = SocketAddr::from(([0, 0, 0, 0], 29000));
    info!("socket address created");
    let outbound_socket = UdpSocket::bind(socket_outbound_address)?;
    let inbound_socket = UdpSocket::bind(socket_inbound_address)?;
    info!("socket bound");

    let mut input_state = input_pin.is_high();

    // let main_task = smol::spawn(async {
    //     info!("{}", 1 + 2);
    //     // async_main().await;
    // });
    // thread::Builder::new().stack_size(4096).spawn(move || {
    //     // smol::block_on(test_tcp_bind()).unwrap();
    //     smol::block_on(async_main()).unwrap();
    // })?;

    // #[cfg(not(esp_idf_version = "4.3"))]
    // test_tcp_bind_async()?;

    // loop {

    //     //TODO check socket for incoming messages

    //     let is_high = input_pin.is_high();
    //     if is_high == input_state {
    //         continue;
    //     }

    //     let message = "test";
    //     socket.send_to(message.as_bytes(), socket_target_address)?;
    //     // let message = String::from_utf8(buffer.into())?;

    //     // Inverse logic to turn LED on
    //     led_pin.set_low().unwrap();
    //     info!("LED ON");
    //     FreeRtos::delay_ms(100);

    //     led_pin.set_high().unwrap();
    //     info!("LED OFF");
    //     FreeRtos::delay_ms(100);

    //     input_state = is_high;
        
    // }

    let target: SocketAddr = SocketAddr::from(format!("{}:{}", "192.168.178.125", "33001").parse::<SocketAddr>().expect("No valid target address given. Use format: <ip>:<port>"));
    let timeout = Duration::from_millis(10);
    inbound_socket.set_read_timeout(timeout.into()).expect("Couldn't set socket timeout");


    let mut timer_generate_data = Instant::now();
    let mut timer_check_incoming = timer_generate_data.clone();

    let mut buf = [0; 1024];

    loop {

        if timer_check_incoming.elapsed().as_millis() > 150 {

            // check socket for incoming data
            if let Ok((message_length, src)) = inbound_socket.recv_from(&mut buf) {
                // convert to string
                let message = String::from_utf8(buf[..message_length].into()).expect("Couldn't convert to String");
                info!("Received data from {}: {}", src, message);

                // parse json
                // let json: serde_json::Value = serde_json::from_str(&message).expect("Couldn't parse JSON");
                // if let Some(message_type) = json["type"].as_str() {
                //     if message_type == "updateTarget" {

                //         // take 10k part from the new target port and fill the rest with the old one
                //         let new_target_port_base = json["target_port_base"].as_u64().expect("No target base port given") as u16;
                //         let new_target_port = new_target_port_base + ((config.target_port % 10000) as u16);
                //         info!("New target port: {}", new_target_port);

                //         let new_target_address_string = format!("{}:{}", json["target"].as_str().expect("No target ip given"), new_target_port);
                //         let new_target_address = SocketAddr::from(new_target_address_string.parse::<SocketAddr>().expect(format!("Target not updated because target address was invalid: {}", new_target_address_string).as_str()));
                //         target = new_target_address;
                        
                //         // acknowledge
                //         let data = generate_input_data();
                //         let json = json!({
                //             "type": "updateTarget",
                //             "success": true,
                //         });
                //         info!("Sending ACK to {}: {}", src, json.to_string());
                //         // send 10 times to "make sure" it arrives
                //         for _ in 0..10 {
                //             outbound_socket.send_to(&json.to_string().as_bytes(), src).expect("Couldn't send ACK");
                //         }
                //     }
                // } 
    
            } else {
                // no data received
                // info!("No data received")
            }

            // reset timer
            timer_check_incoming = Instant::now();
        }
        
        if timer_generate_data.elapsed().as_millis() > 2000 {

            // let data = generate_input_data();
            let data = "test";

            // let json = json!({
            //     "message": data.to_string(),
            //     "meta": {
            //         "flow_name": config.flow_name,
            //         "execution_area": config.area
            //     }
            // });
            
            // info!("Sending data to {}: {}", target, data);
            info!("Sending data to {}: {}", target, data);
            // outbound_socket.send_to(&json.to_string().as_bytes(), target).expect("Couldn't send data");
            outbound_socket.send_to(data.to_string().as_bytes(), target).expect("Couldn't send data");

            // reset timer
            timer_generate_data = Instant::now();
        }
        
    }

}

// fn test_tcp_bind_async() -> anyhow::Result<()> {
//     async fn test_tcp_bind() -> smol::io::Result<()> {
//         /// Echoes messages from the client back to it.
//         async fn echo(stream: smol::Async<TcpStream>) -> smol::io::Result<()> {
//             smol::io::copy(&stream, &mut &stream).await?;
//             Ok(())
//         }

//         // Create a listener.
//         // let listener = smol::Async::<TcpListener>::bind(([0, 0, 0, 0], 8081))?;
//         let socket_address = SocketAddr::from(([0, 0, 0, 0], 8081));
//         let listener = smol::net::UdpSocket::bind(socket_address).await?;

//         let mut buf = [0; 1024];

//         // Accept clients in a loop.
//         // loop {
//             info!("waiting for data");
//             let (n, source) = listener.recv_from(&mut buf).await?;

//             info!("test");
//                 // info!("Accepted client: {}", source);
//                 // info!("Received data: {}", String::from_utf8_lossy(buf[..n].into()));

//             // Spawn a task that echoes messages from the client back to it.
//             // smol::spawn(echo(stream)).detach();
//         // }
//         Ok(())
//     }

//     info!("About to bind a simple echo service to port 8081 using async (smol-rs)!");

//     #[allow(clippy::needless_update)]
//     {
//         esp_idf_sys::esp!(unsafe {
//             esp_idf_sys::esp_vfs_eventfd_register(&esp_idf_sys::esp_vfs_eventfd_config_t {
//                 max_fds: 5,
//                 ..Default::default()
//             })
//         })?;
//     }

//     thread::Builder::new().stack_size(4096).spawn(move || {
//         smol::block_on(test_tcp_bind()).unwrap();
//     })?;

//     Ok(())
// }

// async fn async_main() -> smol::io::Result<()> {

//     // info!("async main");

//     let mut tasks: Vec<smol::Task<Result<(), std::io::Error>>> = vec![];

//     async fn test_task() -> smol::io::Result<()> {
//         info!("{}", 1 + 2);
//         Ok(())
//     }

//     // tasks.push(smol::spawn(test_task()).detach());
//     tasks.push(smol::spawn(test_task()));

//     futures::future::join_all(tasks).await;

//     // warn!("still alive");

//     Ok(())

// }
